p8105_hw1_jz4027
================
Charlotte Zhang
2025-09-17

# Problem 1

``` r
##Load needed library
library(ggplot2)
library(moderndive)
```

### Load dataset

``` r
data("early_january_weather")
```

### Short description of the dataset

This dataset has 358 rows and 15 columns.

The mean temperature is 39.5821229 F.

Variables include: origin, year, month, day, hour, temp, dewp, humid,
wind_dir, wind_speed, wind_gust, precip, pressure, visib, time_hour.

Values (ranges) of some important variables:

- The variable `temp` ranges from 24.08 to 57.92.
- The variable `dewp` ranges from 8.96 to 53.06.
- The variable `wind_speed` ranges from 0 to 24.16638.
- The variable `pressure` ranges from 1010.8 to 1034.4.
- The variable `wind_dir` ranges from 0 to 360.

### ggplot and ggsave

``` r
ggplot(early_january_weather, aes(x = time_hour, y = temp, color = humid)) + geom_point() + labs(x = "Time_hour", y = "Temprature")
```

![](p8105_hw1_jz4027_files/figure-gfm/unnamed-chunk-3-1.png)<!-- -->

``` r
ggsave("p1_scatterplot.pdf", height = 4, width = 6)
```

### Patterns of the scatterplot

- The temperature has an overall increasing trend from early January to
  mid January
- Temperature increases during daytime and decreases at night, a
  repeating daily cycle.
- The color of humidity is generally darker in early January (lower
  humidity), and lighter in mid January (higher humidity).

# Problem 2

``` r
library(tidyverse)
```

    ## ── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──
    ## ✔ dplyr     1.1.4     ✔ readr     2.1.5
    ## ✔ forcats   1.0.0     ✔ stringr   1.5.1
    ## ✔ lubridate 1.9.4     ✔ tibble    3.3.0
    ## ✔ purrr     1.1.0     ✔ tidyr     1.3.1
    ## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
    ## ✖ dplyr::filter() masks stats::filter()
    ## ✖ dplyr::lag()    masks stats::lag()
    ## ℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors

``` r
set.seed(1)

# Create a data frame
p2_df = tibble(
  norm_samp = rnorm(10),
  log_vec = norm_samp > 0,
  char_vec = c("ab","cd","e","fgh","i","j","k","lmn","o","p"),
  factor_vec = factor(c("Level_1","Level_2","Level_3","Level_2","Level_2","Level_3","Level_1","Level_1","Level_2","Level_3"))
)

# Calculate the mean
mean_norm_samp = mean(pull(p2_df, norm_samp))
mean_log_vec = mean(pull(p2_df, log_vec))
mean_char_vec = mean(pull(p2_df, char_vec))
```

    ## Warning in mean.default(pull(p2_df, char_vec)): argument is not numeric or
    ## logical: returning NA

``` r
mean_factor_vec = mean(pull(p2_df, factor_vec))
```

    ## Warning in mean.default(pull(p2_df, factor_vec)): argument is not numeric or
    ## logical: returning NA

- The mean of a random sample of size 10 from a standard Normal
  distribution is 0.13. The mean of a logical vector indicating whether
  elements of the sample are greater than 0 is 0.6. The mean of a
  character vector of length 10 is NA. The mean of a factor vector of
  length 10, with 3 different factor “levels” is NA.
- The first one works because it is a numeric variable. The second one
  is a logical variable, and it works because TRUE=1 and FALSE=0. The
  last two do not work because they are character and factor variables.

``` r
as.numeric(pull(p2_df, log_vec))
as.numeric(pull(p2_df, char_vec))
```

    ## Warning: NAs introduced by coercion

``` r
as.numeric(pull(p2_df, factor_vec))
```

- After converting with as.numeric(), the logical vector becomes 0s and
  1s because TRUE = 1 and FALSE = 0. The mean is simply the proportion
  of TRUEs, which is why we were able to compute it directly even
  without explicit conversion.
- The character vector becomes a bunch of NAs after converting since
  letters/words cannot be interpreted as numeric values. And this is why
  we got NA for the mean.
- The factor vector becomes numbers 1, 2, 3 after converting. These
  numbers are the underlying integer code each level represent, not real
  data values. We got NA for the mean before converting because R does
  not automatically treat them as numeric values.
